import os
import asyncio
from playwright.async_api import async_playwright
from dotenv import load_dotenv
from autogen_core.models import UserMessage
from autogen_ext.models.openai import OpenAIChatCompletionClient

# Load environment variables
load_dotenv()
GITHUB_EMAIL = os.getenv("GITHUB_EMAIL")
GITHUB_PASSWORD = os.getenv("GITHUB_PASSWORD")
GITHUB_REPO_URL = os.getenv("GITHUB_REPO_URL")
GITHUB_REPO_FOLDER = os.getenv("GITHUB_REPO_FOLDER")

# hw3: 
# Function to generate README.md content using Autogen
async def generate_readme_content(model_client, code_content):
    prompt = (
        "## This file is automatically generated by Autogen\n\n"
        "Write a clean and concise `README.md` in English for the following Python script.\n\n"
        "üìå Follow these rules strictly:\n"
        "- Use Markdown headings: `#`, `##`, etc.\n"
        "- Use `-` for bullet points. **Never use numbered lists** like `1.`, `2.`, etc.\n"
        "- Do not use nested bullet points.\n"
        "- Do not use tab characters. Indentation must be flat.\n"
        "- Focus on summarizing the script's purpose, key features, and usage.\n"
        "- Keep the README **under 300 words**.\n"
        "- If you break any of these rules, the output will be rejected.\n\n"
        "üìÑ Python code:\n"
        f"````python\n{code_content}\n````\n\n"
        "üìå At the end of the README, include an example for running the script like this:\n"
        "```bash\npython <your_script>.py\n```"
    )



    # response = await model_client.create([UserMessage(content=prompt, source="user")])
    # readme_content = response.content
    response = await model_client.create([UserMessage(content=prompt, source="user")])
    raw_content = response.content

    # ÂæåËôïÁêÜÔºöÁßªÈô§Êï∏Â≠óÊ∏ÖÂñÆËàáÂ§öÈ§òÁ©∫Ë°å
    cleaned_lines = []
    for line in raw_content.splitlines():
        stripped = line.strip()
        if not stripped:
            continue  # ÁßªÈô§Á©∫Ë°å
        if stripped[:2].isdigit() and stripped[2:3] == ".":
            continue  # ÁßªÈô§Êï∏Â≠óÊ∏ÖÂñÆÈñãÈ†≠ (Â¶Ç 1. 2. 3.)
        if stripped.startswith(tuple(f"{i}." for i in range(1, 10))):
            continue
        cleaned_lines.append(stripped)
    
    readme_content = "\n".join(cleaned_lines)
    return readme_content

# Function to publish README.md to GitHub using Playwright
async def publish_to_github(md_content, file_name="README.md"):
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        page = await browser.new_page()

        # GitHub login
        await page.goto("https://github.com/login")
        await page.fill("#login_field", GITHUB_EMAIL)
        await page.fill("#password", GITHUB_PASSWORD)
        await page.press("#password", "Enter")

        print("Complete 2FA verification manually:")
        input("Press Enter after completing 2FA verification...")
        await page.wait_for_timeout(3000)

        # Navigate to specified repository
        await page.goto(GITHUB_REPO_URL)
        await page.wait_for_timeout(2000)
        print("Entered GitHub Repo")

        # Navigate to autogen folder
        # await page.goto(f"{GITHUB_REPO_URL}/tree/main/autogen/post")
        await page.goto(f"{GITHUB_REPO_URL}/tree/main/{GITHUB_REPO_FOLDER}")
        await page.wait_for_timeout(3000)

        # Click to add new file
        await page.click("button:has-text('Add file')")
        await page.click("a:has-text('Create new file')")

        # Fill file name and content
        await page.fill("input[aria-label='File name']", file_name)
        await page.wait_for_selector("div.cm-content[contenteditable='true']")
        await page.locator("div.cm-content[contenteditable='true']").click()
        await page.keyboard.type(md_content, delay=50)

        # Commit file
        await page.click("button:has-text('Commit changes...')")
        await page.click("button[aria-disabled='false']:has-text('Commit changes')")

        input("Submission completed. Press Enter to close the browser...")
        await browser.close()

# Main function
async def main():
    gemini_api_key = os.getenv("GEMINI_API_KEY")
    if not gemini_api_key:
        print("Please check the GEMINI_API_KEY in the .env file.")
        return

    model_client = OpenAIChatCompletionClient(
        model="gemini-2.0-flash",
        api_key=gemini_api_key,
    )

    # Read content from a Python file
    folder_path = input("Enter the folder path: ").strip()
    file_name = input("Enter the Python file name (e.g. main.py): ").strip()
    file_path = os.path.join(folder_path, file_name)

    if not os.path.isfile(file_path):
        print(f"File not found: {file_path}")
        return

    with open(file_path, "r", encoding="utf-8") as file:
        code_content = file.read()

    readme_content = await generate_readme_content(model_client, code_content)
    await publish_to_github(readme_content)

if __name__ == '__main__':
    asyncio.run(main())
